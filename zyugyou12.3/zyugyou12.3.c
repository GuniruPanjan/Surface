#include<stdio.h>
#include<stdlib.h>
#include<time.h>


int main(void)
{
	int a;
	int* ptA;

	a = 10;
	ptA = &a;      //ポインタに変数のアドレスを格納したい

	//ポインタの場所にある変数の値を表示したい
	printf("ポインタptAに格納されている値は%dです\n", *ptA);

	return 0;
}



/*
int main(void)
{
	int a;
	int* ptA;    //ポインタ　(int型の)アドレスを格納するための変数

	a = 3;      //変数に3を代入
	ptA = &a;     //ポインタに変数aのアドレスを代入する


	//どちらも変数aのアドレス(メモリ上の場所)が表示される
	printf("変数aのアドレスは%pです\n", &a);
	printf("ポインタptAの値は%pです\n", ptA);

	//ポインタからそこに格納されている値を取得したい

	printf("変数aの値は%dです\n", a);
	printf("ptAに格納されている値は%dです\n", *ptA);

	//&は変数からそのアドレスを取得するための演算子
	//* はアドレス（ポインタ）からその中身を取得するための演算子

	return 0;
}
*/






/*
int main(void)
{
	char  c = 'A';        //文字はchar型に格納する
	int i = 10;           //整数はint型に格納する
	float f = 1.23f;      //少数はfloat型に格納する

	printf("変数iのアドレスは%pです\n", &i);

	//&i        アドレスは何に格納する？　　　ポインタに格納する
	int* ptA;
	// int *ptA;    //どちらでもOK　　上の書き方のほうがメジャー
	float* ptB;
	char* ptC;

	printf("ポインタptAのアドレスは%pです\n", ptA);

	int* ptD;

	return 0;
}
*/



/*
int main(void)
{
	int a;

	printf("変数aのアドレスは%pです\n", &a);

	a = 3;
	printf("変数aの値は%dで、アドレスは%pです\n", a, &a);

	a = 5;
	printf("変数aの値は%dで、アドレスは%pです\n", a, &a);

	return 0;
}
*/






/*
int function(void)
{
	int a = 7;

	printf("functionの変数aの中身は%dです\n", a);
}


int main(void)
{
	int a;

	a = 10;     //確保したメモリに変数を保存する

	//↑が作成され、変数が宣言された時点でメモリ上にint型のサイズ分データを保存する領域が確保される
	//int型は4Byte(32bit)なのでその文確保される
	//メモリ上のどこに確保されるかは不明(OS任せ)


	//aを参照するとき、aの内容をOSに問い合わせる必要がある
	//OSは変数の先頭の位置を覚えてる
	//データ型が分かればそこから始まって何バイト分がその変数の内容かがわかる
	//データの先頭位置+データ型からその中身の詳細が分かる
	printf("変数aの中身は%dです\n", a);


	float b;
	b = 1.23f;

	printf("変数bの中身は%fです\n", b);

	//関数の呼び出し
	function();

	//配列
	//配列はどのようにメモリ確保されるのか？

	//配列は必ずメモリ上に連続して配置される
	//置いて問題のない場所（他に確保されているメモリを破壊しない場所）
	//を選んで配置してくれる
	char c[5] = { 0, 0, 0, 0, 0 };
	printf("c[3]の中身は%dです\n", c[3]);

	//配列2
	char d[4] = { 0, 0, 0, 0 };
	//配列の範囲外に値を書き込もうとしている
	//他の事に使われているメモリ上に上書きしてしまう
	//int num = 5;      //ダメな例...d[5]に値を書き込もうとしている
	//d[num] = 100;     //ダメな例２...d[-1]に値を書き込もうとしている

	//DxLibでグラフィックを作った時、
	//グラフィックデータをメモリに読み込んだ(LoadGraph())
	//これもメモリ上に置かれる

	//グラフィックのロードでメモリがいっぱいになった体

	//配列３
	int e[3];      //メモリか確保できないので止まる

	//OSは各変数のメモリ上の開始位置を覚えてる
	//開始位置　+  データ型でどこからどこまでが一つの変数データなのかが分かる
	printf("a = %d\n", a);

	//配列も配列の開始位置を覚えてる
	//配列はメモリ上に必ず連続して配置されるので
	//配列の開始位置 + データ型 + 要素番号
	//を使用して各データにアクセスできる

	//開始位置？
	//メモリには先頭から番号が振られている
	//※0からスタートではないが通し番号が振られている
	//メモリ上の位置を表す通し番号をアドレスという

	//OSは開始位置を覚えてる、と言ったが
	//メモリ上のアドレスを覚えている

	//変数main::aは 0 × 0020 から始まる、みたいな覚え方をしている

	return 0;
}
*/